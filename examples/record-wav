#!perl6

use Audio::PortAudio;
use Audio::Sndfile;

sub MAIN(Str $filename, Str :$source) {
    my $pa = Audio::PortAudio.new;
    my $format = Audio::Sndfile::Info::Format::WAV +| Audio::Sndfile::Info::Subformat::PCM_16;
    my $out-file = Audio::Sndfile.new(:$filename, channels => 2, samplerate => 44100, :$format, :w);
    my $st;
    
    if $source.defined {
        my $index = 0;
        for $pa.devices -> $device {
            if $device.name eq $source {
                if $device.max-input-channels < 2 {
                    die "Device $source does not have enough input channels";
                }
                else {
                    my $la = $device.default-high-input-latency;
                    my $si = Audio::PortAudio::StreamParameters.new(device => $index,
                                                                    channel-count => 2,
                                                                    sample-format => Audio::PortAudio::StreamFormat::Float32,
                                                                    suggested-latency => 0.05e0 );
                    $st = $pa.open-stream($si, Audio::PortAudio::StreamParameters, 44100, 0 );
                    last;
                }

            }
            $index++;
        }
        if !$st.defined {
            die "Couldn't find a device for '$source'";
        }
    }
    else {
        $st = $pa.open-default-stream(2,0, Audio::PortAudio::StreamFormat::Float32, 44100);
    }
    $st.start;
    my $p = Promise.new;
    signal(SIGINT).tap({
        say "stopping recording";
        $p.keep: "stopped";
        $out-file.close;
        $st.close;
        exit;
    });
    my Channel $write-channel = Channel.new;
    my $write-promise = start {
        react {
            whenever $write-channel -> $item {
                if $p.status ~~ Planned {
                    say "going to write '{ $item.elems / 2 }' frames";
                    $out-file.write-float($item);
                    $out-file.sync;
                }
                else {
                    done;
                }
            }
        }
    };

    loop {
        if $p.status ~~ Planned {
            my $f = $st.read-available;
            if $f > 0 {
                my $buff = $st.read($f,2, num32);
                my @b;
                @b[$_] = $buff[$_] for ^($f * 2);#8192;
                $write-channel.send(@b);
            }
        }
        else {
            last;
        }
    }

}


# vim: expandtab shiftwidth=4 ft=perl6
